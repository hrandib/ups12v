#! /usr/bin/python

import serial
import configparser
import signal
import os
import time
import functools

MAX_INPUT_LEN = 512

# Disable buffering
print = functools.partial(print, flush=True)

conf = configparser.ConfigParser()

files = conf.read(['/etc/ups-daemon.conf', 'ups-daemon.conf'])
if files:
    print(f'Config(s) path: {", ".join(files)}')
else:
    print('Config file is not accessible. Exiting')
    exit(-2)

ser = None
port = conf.get('UPS', 'Tty', fallback='ttyACM0')
try:
    ser = serial.Serial('/dev/' + port, exclusive=True, timeout=0.2)
except serial.SerialException:
    print(f'Port {port} is not available. Exiting')
    exit(-1)


def signal_handler(sig, frame):
    print(' SIGINT captured')
    exit(0)


signal.signal(signal.SIGINT, signal_handler)


def port_is_alive():
    try:
        ser.inWaiting()
        return True
    except serial.SerialException:
        return False


def send_command(*cmd_with_args):
    if not port_is_alive():
        print("Port disconnected. Exiting")
        exit(-1)
    cmd = ' '.join(map(str, cmd_with_args))
    ser.write(b'\x03\r')
    time.sleep(0.1)
    ser.reset_input_buffer()
    ser.write(bytes(f'{cmd}\r', 'utf8'))
    ser.readline()
    output = ser.read(MAX_INPUT_LEN).decode('utf8')
    output = output[0:output.rfind('\r\n')]
    return output


def set_limits():
    ups = conf['UPS']
    if conf.has_option('UPS', 'LimitCharge'):
        val = ups['LimitCharge']
        print(f"Limit charge to {val}% >", end=' ')
        res = send_command('limit-charge', val)
        print(res)
    if conf.has_option('UPS', 'LimitIdleDischarge'):
        val = ups['LimitIdleDischarge']
        print(f"Limit idle discharge {val}% >", end=' ')
        res = send_command('limit-discharge', val)
        print(res)


set_limits()

shutdown_threshold = conf.getint('UPS', 'ShutdownThreshold', fallback=30)
print(f'Shutdown will be initiated reaching {shutdown_threshold}% battery level during discharge')

shutdown_triggered = False


def shutdown():
    global shutdown_triggered
    if not shutdown_triggered:
        print('Shutdown initiated')
        shutdown_triggered = True
        os.system('shutdown +1')


def cancel_shutdown():
    global shutdown_triggered
    print('Shutdown canceling')
    shutdown_triggered = False
    os.system('shutdown -c')


def log_db(v12, vbat, diff, level, state):
    print(f'To DB: {v12} {vbat} {diff} {level} {state}')


def log_dummy(*args):
    pass


log = log_db if conf.has_option('INFLUXDB', "Host") else log_dummy
prev_message = ''
prev_level = 0


def thin_out_print(state, level):
    global prev_message, prev_level
    if (state in ['IDLE', 'DISCHARGE'] and prev_level > level) \
            or (state == 'CHARGE' and prev_level < level) \
            or (state == 'TRICKLE' and prev_level != level):
        prev_level = level
        if level % 5 == 0:
            message = f'State: {state} {level}%'
            if prev_message != message:
                prev_message = message
                print(message)  # system log


print(send_command('poll'))
prev_state = 'IDLE'


def adjust_prev_state(state):
    global prev_state, prev_level
    if prev_state != state:
        prev_state = state
    if state in ['IDLE', 'DISCHARGE']:
        prev_level = 100
    elif state in ['TRICKLE', 'CHARGE']:
        prev_level = 0


def main_loop():
    global prev_state, prev_level
    ser.timeout = 2
    while True:
        try:
            args = ser.readline().split()
        except serial.SerialException:
            print("Port disconnected. Exiting")
            exit(-1)
        v12, vbat, diff, level = map(int, args[:-1])
        state = args[-1].decode('utf8')
        adjust_prev_state(state)
        thin_out_print(state, level)
        if state in ['CHARGE', 'DISCHARGE', 'TRICKLE']:
            log(v12, vbat, diff, level, state)
        if state == 'DISCHARGE' and level <= shutdown_threshold:
            shutdown()
        if state == 'CHARGE' and shutdown_triggered:
            cancel_shutdown()


main_loop()
